
























Chapter Goals:

	Scope (python interpreter search pattern)
		- local scope 			(L)
		- enclosing scope 		(E)
		- global scope 			(G)
		- built-in scope 		(B)



	Interpreter and Storage
		- runtime stack
		- heap
























Introduction  ( recursion thinking ):

	DON'T THINK TOO HARD! That’s one of the central themes of this chapter. 


	Most computer science students start by learning 
	to program in a style called IMPERATIVE PROGRAMMING. 
		- This simply means that you are likely used to thinking about 
		- creating variables, 
		- storing values, 
		- and updating those values as a program proceeds. 


	In this chapter you are going to begin learning 
	a different style of programming called FUNCTIONAL PROGRAMMING. 
		- Here, you think much more about the definition of what you are programming
		- than how you are going to program it.  HMMM....


	Some say that writing recursive functions
	is a declarative approach rather than an imperative approach. 
	(declarative approach?  & imperative approach?)


	You’ll start to learn what that means for you very soon. 


	Finally, when you start to get good at writing recursive functions 
	you’ll be surprised how easy it can be! 
























Introduction 	( chapter objectives ):

	• How does Python determine the meaning of an identifier in a program?

	• What happens to the run-time stack when a function is called?

	• What happens to the run-time stack when a function returns from a call?

	• What are the two important parts to a recursive function 
	  and which part comes first?

	• Exactly what happens when a return statement is executed?

	• Why should we write recursive functions?

	• What are the computational complexities of various recursive functions?
























Python Interpreter :

	Python programs are executed by an interpreter.


	An interpreter 
		- is a program that reads another program 
		- as its input and does what it says. 
		- The Python interpreter, usually called python, 
		- was written in a language called C. 

		- that C program reads a Python program 
		- and does what the Python program says to do in its statements. 


	An interpreter 
		- interprets a program by running or executing what is written within it. 
		- the interpreter interacts with the operating system of the computer to use 
			the network,
			the keyboard, 
			the mouse, 
			the monitor, 
			the hard drive, 
			and any other I/O device 
		- that it needs to complete the work /
		- that is described in the program it is interpreting. 


	In this chapter, Firstly 
		- we’ll introduce you to three entities
		- the scope, 
		- the run-time stack, 
		- the heap 

		- this entities will help you understand 
		- HOW THE INTERPRETER CALLS FUNCTIONS, 
		- WHERE LOCAL VARIABLES ARE STORED.


	In this chapter, Lastly 
		- we’ll provide several examples of recursive functions 
		- so you can begin to see how they are written, the framework of thinking. 
		- we’ll apply recursion to drawing pictures as well.
























Scope  ( local scope ): 

	Lets not forget a very important basic concepts
	which is, variables in python are references not the objects themselves


	Scope 
		- refers to a part of a program 
		- where a collection of identifiers are visible. 
		- Let’s look at a simple example program.


	Local Scope
		- this is the scope of the function 
		- that the computer is currently executing. (Hmmm...)

		- When your program is executing a line of code, 
		- the scope that surrounds that line of code is called the local scope. 

		- When you reference an identifier in a statement in your program,
		- Python first examines the local scope to see if the identifier is defined there, 
























Scope  (local scope identifier):

	A local scope identifier, "id", is defined under one of three conditions.	

	Condition 1
	    A statement like id = … 
	    appears somewhere within the current scope. 
	    in this case, id would be a reference to an object in the local scope.


	Condition 2    	
		id appears as a parameter name of the function in the current scope. 
		In this case, id would be a reference to an object that was passed 
		to the current function as an argument.


	Condition 3		
		id appears as a name of a function or class 
		through the use of a function def or class definition within the current scope. 
		(so function & class names are included as identifiers)


	If Python finds id in the local scope, 
	it looks up the corresponding value and retrieves it.
























Scope  ( enclosing scope - intro ):

	If Python does not find the reference id within the local scope, 
	it will examine the Enclosing scope to see if it can find id there. 


	Again, Python looks for the identifier in the enclosing scope
	using the same conditions as defined for the local scope.


	Module Scope
		- scopes are nested. 
		- this means that each scope is nested inside another scope.
		- the final enclosing scope of a module is the module itself. 
		- each module has its own scope. 

		- identifiers that are defined outside of any other functions, 
		- but inside the module, are at the module level.   
























Scope  ( enclosing scope - visibility ):

	While executing line 23 of the program in Fig. 3.2 
		- identifier val is defined in the local scope. 
		- but, val is also defined in the enclosing scope. 
		- this is acceptable and often happens in Python programs. 


	Each scope has its own copy of identifiers.
		- the choice of which "id" is visible is made by always selecting /
		- the innermost scope that defines the identifier. 
		- whilst the outer scope with the "id" identifier will be hidden


	This is why it is important 
		- that we choose our variable names /
		- and identifiers carefully in our programs. 
		- because of access


	Every function definition (including the definition of methods) 
	within a module defines a different scope. 

	The scope never includes the function name itself, 
	but includes its parameters and the body of the function. 	
























Scope  ( global scope ) :

	Using Python it is possible to define variables at the Global level. 


	Generally this is a bad programming practice 
	and we will not do this in this text. 


	If interested you can read more about global variables in Python online. 


	But, using too many global variables will generally lead to name conflicts 
	and will likely lead to unwanted side effects. 


	Poor use of global variables contributes to spaghetti code which is named
	for the big mess you would have trying to untangle it to figure out what it does.
























Scope  ( built-in scope ):

	The final scope in Python is the Built-In scope. 
		- if an identifier is not found 
		- within any of the nested scopes within a module 
		- and it is not defined in the global scope, 

		- then Python will examine the built-in identifiers 
		- to see if it is defined there. 
		- For instance, consider the identifier "int". 

		- x = int("6")
		- the Built-In scope defines the "int" class or type
		- if you define an identifier called "int" as we explained before,
		- you wont be able to use the Built-In functionality


	This is why you should not use identifiers
	that already exist in the built-in scope.


	The word "LEGB" is an acronym meaning
		- local scope
		- enclosing scope
		- global scope
		- built-in scope
		(highlighting the python interpreter search pattern)
























Storage  ( intro ):

	As we learned in the last section, 
		- the parameters and body of each function 
		- define a scope within a Python program. 


	The parameters and variables defined within the local scope of a function 
	must be stored someplace within the RAM of a computer.


	Python splits the RAM up into two parts called 
		- the Run-time Stack 
		- and the Heap.
























Storage  ( stack ):

	Typical stack analogy
		- the run-time stack is like a stack of trays in a cafeteria. 
		- most cafeterias have a device that holds these trays. 
		- when the stack of trays gets short enough 
		- a SPRING below the trays, pops the trays up 
		- so they are at a nice height. 
		- as more trays are added to the stack, 
		- the spring in this device compresses and the stack pushes down. 


	Run-Time Stack 	
		- this is similar in many ways to the typical stack. 
		- the run-time stack is a stack of ACTIVATION RECORD. 
		- the Python interpreter pushes an activation record 
		- onto the run-time stack when a function is called. 

		- when a function returns the python interpreter 
		- pops the corresponding activation record off the run-time stack.

		- Thus the state of the run-time Stack is dependent 
		- on the current line the interpreter is executing
		  interesting!!
























Storage   ( activation record ):

	Activation Record
		- python stores the identifiers defined 
		- in the local scope in an activation record.

		- when a function is called, 
		- a new scope becomes the local scope. 

		- At the same time 
		- a new activation record is pushed onto the run-time stack. 
		- this new activation record holds all the variables 
		- that are defined within the new local scope. 

		- when a function returns 
		- its corresponding activation record 
		- is popped from the run-time stack.
























Storage  ( heap ):

	The Heap 
		- this is the area of RAM where all objects are stored. 
		- when an object is created it resides in the heap. 
		- The run-time stack never contains objects. 
		- references to objects are stored within the run-time stack 
		- and those references point to objects in the heap.
		HMMM......
























Storage  ( extra-note ):


	Two things happen in a scope.
		- an identifier value is used	
		- an identifier value is created/assigned


	When a Scope uses an identifier it did not create
		- in this scenario, when an identifier value is used, 
		- the interpreter searches via LEGB for this identifier value
		- so it can use it.

		- the Activation Record of this scope will include that identifier.
		- even if the identifier actually dwells in an outer scope
		- its reference, the same reference will be in local scope activation record
		- python implementation makes this so.
		  DO YOU UNDERSTAND


	When a Scope uses an identifier it did create/assign
		- if the identifier name is the same with another 
		- in an outer encapsulating scope 
		- the other identifier will be hidden
























Recursive Function  ( intro ):

	A recursive function is simply a function that calls itself. 
	It’s really very simple to write a recursive function, 


	Stack Overflow 
		- if a function just kept calling itself 
		- it would never finish. 

		- actually, 
		- it would finish when run on a computer 
		- because we just learned that every time you call a function, 
		- an activation record is pushed on the run-time stack. 

		- if a recursive function continues to call itself over and over 
		- it willeventually fill up the run-time stack 
		- and you will get a stack overflow error 
		- when running such a program


	Base Case
		- to prevent a recursive function from running forever, 
		- or overflowing the runtime stack, 
		- every recursive function must have a base case, 
		- just like an inductive proof must have a base case. 

		- there are many similarities 
		- between inductive proofs and recursive functions. 
		- the base case in a recursive function must be written first,
		- before the function is called recursively.
























Recursive Function 	( thinking approach ):

	Now, 
		- wrapping your head around just how a recursive function works 
		- is a little difficult at first. 

		- Actually, 
		- understanding how a recursive function works isn’t all that important. 

		- When writing recursive functions  
		- we want to think more about what it does than how it works. 

		- It doesn’t pay to think too hard 
		- about how recursive functions work, 
		- but in fact even that will get much easier with some practice.
























Recursive Function (rule of thumb):

	when writing a recursive function there are four rules that you adhere to. 

	Rule 1
		- decide on the name of your function and the arguments 
		- that must be passed to it to complete its work 
		- as well as what value the function should return.


	Rule 2	
		- write the base case for your recursive function first. 
		- the base case is an if statement that handles a very simple case 
		- in the recursive function by returning a value.


	Rule 3	
		- finally, you must call the function recursively 
		- with an argument or arguments that are smaller in some way 
		- than the parameters that were passed to the function when the last call was made. 
		- the argument or arguments that get smaller 
		- are the same argument or arguments you examined in your base case.


	Rule 4
		- look at a concrete example. 
		- pick some values to try out with your recursive function. 
		- trust that the recursive call you made in the last step works. 

		- Take the result from that recursive call 
		- and use it to form the result you want your function to return. 
		- use the concrete example to help you see how to form that result.
























Recursive function	(a simple example):

	Lets create a function that returns the sum of the first n number.


	we saw how to obtain this result mathematically in our last chapter
	leading to an O(1) notation via the equation n(n+1)/2.


	This time, we will show how to write this function recursively
		- name of function: sumFirstN

		- argument :	n

		- result : n + (n-1) + ... + 1 + 0

		- base case: if n==0; return n;

		- reduction tactic: sumFirstN(n-1)

		- recursive case: return n + sumFirstN(n-1) 

		- function:
			sumFirstN(n):
				if n == 0:
					return 0

				return n + sumFirstN(n-1)


	Think visually of the process the python interpreter will take,
	pushing activation records into the run-time stack.


	Thus, there is a copy for each function call, When a function call returns, 
	the corresponding activation record is popped off the run-time stack. 


	This is how a recursive function is executed.

		
























Recursive function (reversing a list):

	f([1, 2, 3, 4]) --> [4, 3, 2, 1]

	f([1, 2, 3, 4]) --> f([2, 3, 4]) + [1] --> [4, 3, 2, 1]

	f([2, 3, 4])    --> f([3, 4]) + [2]    --> [4, 3, 2]

	f([3, 4])       --> f([4]) + [3]       --> [4, 3] 

	f([4])      --> f([]) + [4]      --> [4]

	f([])     --> []     


	Here is one of the mental model when using recursion to reverse a list


	def rev(lst):
		if lst == []:
			return []

		
		# obtain the first item in list
		last = rev[0]


		# reverse the rest of the list excluding first in list	
		rev_rest = rev(list[1:])	


		# combine
		rev_lst = rev_rest + last


		return rev_lst
























Recursive function (reversing a list):

	Insteading of slicing, 
		- we can use another mental model wherein we use INDEXING	. 
		- such that we start indexing from the last to the first
		- we will use CLOSURES to achieve this

			[]
			[1] + []        = [1]
			[2] + [1]       = [2, 1]
			[3] + [2, 1]    = [3, 2, 1]
			[4] + [3, 2, 1] = [4, 3, 2, 1]   


			def rev2(lst):

				rev_helper(index):
					if index == -1:
						return []

					return [lst[index]] + rev_helper(index-1)

				return rev_helper(len(list)-1)


	In this example, 
		- we make a list or string smaller 
		- without actually making it physically smaller. 

		- Using an index to keep track of your position within a list 
		- can serve to make the list or string smaller. 
		- in that case it may be helpful to write a function 
		- that calls a helper function to do the recursion. 


	One other thing to note. 
		- in this example the index gets smaller by approaching zero on each recursive call.
		- this example could be rewritten so the index grows toward the length of the list. 
		- it all depends on your mental model.
























Using Type Reflection:

	If we were to reverse the a string and not a list
	the mental model will still be the same, all that will change is little syntax
		- we use the string concatenation operator instead of the list concatenation operator 
		- and the empty string instead of the empty list.


	Therefore to generalise this, we will use TYPE REFLECTION
	Python has another very nice feature called reflection.


	Reflection 
		- refers to the ability for code to be able to examine 
		- attributes about objects that might be passed as parameters to a function. 

		- One interesting aspect of reflection 
		- is the ability to see what the type of an object is. 
		- and use the class object that is returned.

		- if we write type(obj) 
		- then Python will return an object which represents the type of obj. 
		- for example, type("a") will return the class object for string (str)
		- writing str() will return an empty string
		- likewise, writing list() is the same thing as writing []. 


	Therefore, Using reflection, 
		- we can write one recursive reverse function that will work for 
		- strings, lists, and any other sequence that supports slicing and concatenation. 
		- This leads to a polymorphic version of recursive reverse, pretty cool!!


		rev(seq_object):
			class_object = type(seq_object)
			empty_version = class_object()


			if seq_object == empty_version:
				return empty_version


			rev_rest = rev(seq_object[1:])			
			first_item = [ seq_object[0:1] ]


			return rev_rest + first_item











