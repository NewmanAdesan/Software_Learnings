Sessions


SESSION (intro)
Sessions are how web servers remembers information about each user, 
which enables features like 
allowing users to stay logged in, and 
saving items to a shopping cart. 


SESSION (stateful & stateless)
These features require our server to be stateful, 
or having access to additional state, or information. 
HTTP on its own is stateless, since after we make a request and get a response, 
the interaction is completed.



SESSION (cookies)
It turns out that servers can send another header in a response, called Set-Cookie:
    HTTP/1.1 200 OK
    Content-Type: text/html
    Set-Cookie: session=value
    ...

Cookies are small pieces of data from a web server that the browser saves for us. 
in many cases, they are large random numbers 
or strings used to uniquely identify and track a user between visits.
In this case, the server is asking our browser to set a cookie for that server, 
called session to a value of value.
then, when the browser makes another request to the same server, 
it’ll send back the same cookie that the same server has set before:
    GET / HTTP/1.1
    Host: gmail.com
    Cookie: session=value

In the real world, amusement parks might give you a hand stamp 
so you can come back inside after leaving. 
similarly, our browser is presenting our cookies back to the web server, 
so it can remember who we are.





LOGIN APP ( configure session )

    - in Flask, we can use the flask_session library 
    - to help manage the whole concept of session for us, 
    - in a new app called login:

        from flask import Flask, redirect, render_template, request, session
        from flask_session import Session

        # Configure app
        app = Flask(__name__)

        # Configure session
        app.config["SESSION_PERMANENT"] = False
        app.config["SESSION_TYPE"] = "filesystem"
        Session(app)

    - we’ll configure the session library to use the server’s filesystem, 
    - and use session like a dictionary to store a user’s name. 
    - it turns out that Flask will use HTTP cookies for us, 
    - to maintain this session variable for each user visiting our web server. 
    - every user will be logged in with a different session, 
    - and we can see them in the flask_session directory:

        src9/login/flask_session/ $ ls
        2029240f6d1128 be89ddc32729463129





LOGIN APP ( operation )
    - we’ll visit our server’s URL, 
    - and get redirected to the /login route automatically.

    - we see a form that we can fill in, which we fill 
    - and then redirected back to the index route, /, 
    - with “You are logged in as David.” 

    - then, we can reload the page, 
    - or open it again in a new tab, 
    - and see the same message. no need to login again
    - we can also use the “Log out” link to log out.





LOGIN APP ("/" route)
    - for our default / route, 
    - if there’s no name set in session for the user yet,
    - we’ll redirect to /login. 
    - otherwise show a default index.html template.

    - looking at the otherwise, two things are involved
    - this aspect is not something i should say now, but i will nonetheless
    - what two things are involved?

    - its either "THE USER IS LOGGED IN" 
    - or "THE USER LOGGED IN AND HAS LOGGED OUT"
    - newman what the heck are you talking about? WAIT
    - you see, when a user logs in, his name is etched into the session library
    - the session library stores his name & his cookie number

    - by etched i mean, even if the user logs out 
    - his name will still be in the session library, 
    - but it wont store a cookie number,
    - rather there will be a flag so you can know he has logged out 

    - why am i saying this, initially there are two cases
    - case 1: if no name set in session for the user yet
    - case 2: if name set in session for the user

    - my point is this, case 1 can only happen once, just once
    - which is when the user first logs in,
    - because his name is etched into the session library, 
    - so even if he logs out, his name is still in the session library
    - so if we dont do something, when he receives index.html, it will still say you are logged in
    - it is now up to index.html to check via that flag if the user is STILL LOGGED IN or has LOGGED OUT   
    - this is crazy.

    - this would have just been more easier if when a name is stored in a session,
    - it can be removed completely. 



@app.route("/")
def index():
    if not session.get("name"):
        return redirect("/login")               # a GET request to "/login"
    return render_template("index.html")





For our /login route, if we visited the route via GET, 
as is the case, when we got to this route via the default route
we’ll render the login form at login.html
this html has a form that obtains a "Name" information
and sends the form back to "/login" but with a POST http method

this is possible because the "/login" route supports GET & POST methods
we’ll store name in session to the form’s value sent via POST, 
and then redirect to the default route. :

@app.route("/login", methods=["GET", "POST"])
  def login():
      if request.method == "GET":
        return render_template("login.html")   

      elif request.method == "POST":
          session["name"] = request.form.get("name")
          return redirect("/")


Then, in our login.html, 
{% extends "layout.html" %}

{% block body %}

    <form action="/login" method="post">
        <input autocomplete="off" autofocus name="name" placeholder="Name" type="text">
        <input type="submit" value="Log In">
    </form>

{% endblock %}    





In our index.html, 
we can check if session["name"] exists, and show different content if so:
{% extends "layout.html" %}

{% block body %}

    {% if session["name"] %}
        You are logged in as {{ session["name"] }}. <a href="/logout">Log out</a>.
    {% else %}
        You are not logged in. <a href="/login">Log in</a>.
    {% endif %}

{% endblock %}


For our /login route, we’ll store name in session to the form’s value sent via POST, and then redirect to the default route. If we visited the route via GET, we’ll render the login form at login.html:
@app.route("/login", methods=["GET", "POST"])
  def login():
      if request.method == "POST":
          session["name"] = request.form.get("name")
          return redirect("/")
      return render_template("login.html")
Then, in our login.html, we can have a form that can submit to itself:
{% extends "layout.html" %}

{% block body %}

    <form action="/login" method="post">
        <input autocomplete="off" autofocus name="name" placeholder="Name" type="text">
        <input type="submit" value="Log In">
    </form>

{% endblock %}



For the /logout route, 
we can clear the value for name in session 
by setting it to None, and redirect to / again:
@app.route("/logout")
def logout():
    session["name"] = None
    return redirect("/")