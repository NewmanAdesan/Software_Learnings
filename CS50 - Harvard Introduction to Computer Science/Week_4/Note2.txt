




Implement a program that applies filters to BMPs, per the below.
    $ ./filter -r IMAGE.bmp REFLECTED.bmp

    - IMAGE.bmp is the name of an image file 
    - REFLECTED.bmp is the name given to an output image file, now reflected.
























Image Representation:

    + Perhaps the simplest way to represent an image 
      is with a grid of pixels (i.e., dots), each of which can be of a different color. 


    + For black-and-white images, we thus need 1 bit per pixel, 
      as 0 could represent black and 1 could represent white, as in the below.


    + In this sense, then, is an image just a bitmap (i.e., a map of bits). 
      For more colorful images, you simply need more bits per pixel. 


    + A file format (like BMP, JPEG, or PNG) 
      that supports “24-bit color” uses 24 bits per pixel. 
      (BMP actually supports 1-, 4-, 8-, 16-, 24-, and 32-bit color.)
























BitMap File (metadata):

    Recall that a file is just a sequence of bits, arranged in some fashion. 


    A 24-bit BMP file, then, is essentially just a sequence of bits, 
    (almost) every 24 of which happen to represent some pixel’s color. 


    But a BMP file also contains some “metadata,” information like an image’s height and width. 


    That metadata is stored at the beginning of the file in the form of two data structures 
    generally referred to as “headers,” not to be confused with C’s header files. 


    (Incidentally, these headers have evolved over time. 
    This problem uses the latest version of Microsoft’s BMP format, 4.0, 
    which debuted with Windows 95.)


    The first of these headers, called BITMAPFILEHEADER, is 14 bytes long. 


    The second of these headers, called BITMAPINFOHEADER, is 40 bytes long. 
























BitMap File ( pixel data ):

    Immediately following these headers is the actual bitmap: 
    an array of bytes, triples of which represent a pixel’s color. 


    However, BMP stores these triples backwards (i.e., as BGR), 
        - with 8 bits for blue, 
        - followed by 8 bits for green, 
        - followed by 8 bits for red. 


    In other words, 
        - were we to convert the 1-bit smiley above to a 24-bit smiley (BGR), 
        - substituting red for black, white is still white 

        - all zeros for green section, all zeros for blue section, all ones for red section 
        - for the color RED, 0x0000ff 

        - all ones for green section, all ones for blue section, all ones for red section
        - for the color WHITE, 0xffffff


    Extra-Note
        - Some BMPs also store the entire bitmap backwards, 
        - with an image’s top row at the end of the BMP file.

        - But we’ve stored this problem set’s BMPs as described herein, 
        - with each bitmap’s top row first and bottom row last.) 
























Image Filtering

    What does it even mean to filter an image? 
        - you can think of filtering an image 
        - as taking the pixels of some original image, 
        - and modifying each pixel in such a way that a particular effect 
          is apparent in the resulting image.
























Grayscale Filtering (gray pixel - intro) :

    One common filter is the “grayscale” filter, 
    where we take an image and want to convert it to black-and-white. 


    Black pixel
        - recall that if the red, green, and blue values 
        - are all set to 0x00 (hexadecimal for 0), 
        - then the pixel is black. 


    White pixel
        - if all values are set to 0xff (hexadecimal for 255), 
        - then the pixel is white. 


    Gray pixel
        - thus, so long as the red, green, and blue values are all equal, 
        - the result will be varying shades of gray along the black-white spectrum, 
        - with higher values meaning lighter shades (closer to white) 
        - and lower values meaning darker shades (closer to black).  
























Grayscale Filtering (gray pixel - average):

    So to convert a pixel to grayscale, we just need to make sure that 
    the red, green, and blue values are all the same value. 


    But how do we know what value to make them? 
        - well, it’s probably reasonable to expect that 
        - if the original red, green, and blue values were all pretty high, 
        - then the new value should also be pretty high. 
        - and if the original values were all low, 
        - then the new value should also be low.    

        - In fact, to ensure each pixel of the new image  
        - still has the same general brightness or darkness as the old image, 
        - we can take the average of the red, green, and blue values 
          to determine what shade of grey to make the new pixel.


    If you apply that to each pixel in the image, 
    the result will be an image converted to grayscale   
























Reflection Filtering:

    Some filters might also move pixels around. 


    Reflecting an image, for example, is a filter where the resulting image 
    is what you would get by placing the original image in front of a mirror. 


    So any pixels on the left side of the image should end up on the right, and vice versa.


    Note that all of the original pixels of the original image 
    will still be present in the reflected image, 


    it’s just that those pixels may have rearranged to be in a different place in the image.
























Blur Filtering:

    There are a number of ways to create the effect of blurring or softening an image. 


    For this problem, we’ll use the “box blur,” 
        - which works by taking each pixel 
        - and, for each color value, giving it a new value 
        - by averaging the color values of neighboring pixels.


    Considering the neighbouring pixel btw the 3x3 box  
























Sepia Filtering:

    Most image editing programs support a “sepia” filter, 


    This gives images an old-timey feel by making the whole image look a bit reddish-brown.


    An image can be converted to sepia by taking each pixel, 
    and computing new red, green, and blue values based on the original values of the three.


    There are a number of algorithms for converting an image to sepia, 
    but for this problem, we’ll ask you to use the following algorithm.   
        sepiaRed   = .393 * originalRed + .769 * originalGreen + .189 * originalBlue
        sepiaGreen = .349 * originalRed + .686 * originalGreen + .168 * originalBlue
        sepiaBlue  = .272 * originalRed + .534 * originalGreen + .131 * originalBlue


    Note Two things
        - each value could be rounded to the nearest integer. 
        - each value should be capped at 255

        - As a result, we can guarantee that the resulting red, green, and blue values 
          will be whole numbers between 0 and 255, inclusive.           


