

01.  Hexadecimal representation   (42)
02.  Pointer concept              (83)
03.  Segmentation fault           (138)     
04.  Deference operator           (170)
05.  Strings and char*            (230)
06.  Pointer arithmetic           (291, 237)
07.  String comparison            (337)
08.  Pointer pointer              (432)     
09.  Memory allocation            (464, 536, 577)
10.  Garbage values               (647, 712)
11.  Arguments in C               (771) 
12.  Memory Sectioning in C       (830) 
13.  Input from user              (838, 887)    
14.  Working with files           (990) 
15.  Exercise 1                   (1041)    
16.  Exercise 2
























Hexadecimal Representation:

        + The values in a computer’s memory are still stored as binary, 
          but hexadecimal representation helps us humans represent larger numeric values 
          with fewer digits needed.

            for instance:
                8 bits   => 11111111 => 255  (binary)
                2 digits => FF       => 255  (hexadecimal)



        + For our computer’s memory, too, we’ll see hexadecimal 
          used to describe each address or location

              // four byte in our computer have the binary value 50
              int n = 50;   
























Pointer Concept:

        + A pointer is a variable that stores an address in memory, 
          where some other variable might be stored.


        + check this out:

            int n = 50;
            int *p = &n; 

            printf("%p\n", p);   -->  0x7ffcb4578e5c  --> the address of n(value of the pointer itself) 


        + The & operator can be used to get the address of some variable, as with &n. 


        + And the * operator declares a variable as a pointer, as with int *p, 
          indicating that we have a variable called p that points to an int. 


        + So, to store the address of a variable n into a pointer p, 
          we would write:   int *p = &n;


        + "p" in now a pointer, which simply is a variable that stores an address 


        + %p is the format code to print an address with printf. 
          this will take the variable given knowing it is a pointer
          and prints the address the pointer refers to.
























Segmentation Fault  (brief intro):  

        + With C, we can also go to specific addresses in memory, 
          which might cause segmentation faults, 


        + where we’ve tried to read or write to memory we don’t have permission to.
          an interesting concept right, more on this later.
























Deference Operator:

        + "*" is the symbol for deference operator.
          notice we used the symbol to declare a pointer (variable that stores an address)


        + here, "*" as a deference operator has a slightly different perspective to it.
          not entirely a different meaning per say, as the two usage are quite related
          you will soon see what i am talking about.

          still, it will still be profitable to differentiate the two usage.
          you will be able to differentiate from the two usage based on the "CONTEXT"
          The former, was in a "CONTEXT of ASSIGNMENT"
          The latter, is in a "CONTEXT of QUERY"


        + "*" as a deference operator, goes to an address to get the value stored there.
            int n = 50;
            int *p = &n;

            printf("%p\n", p);      -> the value of the pointer itself (an address)
            printf("%i\n", *p);     -> the value at the address


        + Since we declared p to be an int *, 
          the compiler knows that *p is an int, so the right number of bytes are read.
          This is how the two perspectives are related, let me explain again.

            - looking at this statement  ( int *p )

            - first perspective is we are declaring a pointer named p
              which basically is a variable that stores an address as it's value

            - second perspective is, using the deference operator concept is telling the compiler
              "the value at the address that pointer p stores is an int" 
              do you get? 
























Strings and Char*:

        + We can declare a string with string s = "HI!";, 
          which will be stored one character at a time in memory (contiguously. 
          and we can access each character with s[0], s[1], s[2], and s[3]:

                H,  I,  !,  \0


        + But it turns out that each character, since it’s stored in memory, 
          also has some unique address, 
          and s is actually just a pointer with the address of the first character:


        + Recall that we can read the entire string by starting at the address in s, 
          and continue reading one character at a time from memory until we reach \0


        + It turns out that string s = "HI!" is the same as char *s = "HI!";. 
          And we can use strings in C in the exact same way without the CS50 Library, by using char *


            char *s =  "HI!";
            printf("%s\n", s);

            printf("%p\n", s);          --> the address of the first character
            printf("%p\n", s[1]);       --> ERROR! because s[1] is not a pointer, but a characted

            printf("%p\n", &s[1]);      --> address of the second character (0x402005)
            printf("%p\n", &s[2]);      --> address of the third character  (0x402006)
            printf("%p\n", &s[3]);      --> address of the fourth character (0x402007)



        + In the CS50 Library, a string is defined with just << typedef char *string >>;. 
          With typedef, we’re creating a custom data type for the word "string", 
          making it equivalent to char *
























Pointer Arithmetic  (concept):

        + do note that string in essense are actually arrays in memory
          meaning they are contiguous addresses, 
          meaning we can navigate from the first to the last using mere addition

            int n[] = [1, 2, 3, 4, 5];

            printf("%c\n", *n);
            printf("%c\n", *(n+1));
            printf("%c\n", *(n+2)); 
            printf("%c\n", *(n+3)); 
            printf("%c\n", *(n+4)); 


        + *n goes to the address stored in n, 
          and *(n + 1) goes to the location in memory with the next character, 
          an address that is one byte higher.


        + n[1] is syntactic sugar, like an abstraction for *(n + 1), 
          equivalent in function but more human-friendly to read and write.     
























Pointer Arithmetic  (concept):      

        + Pointer arithmetic 
            - is the process of applying mathematical operations to pointers, 
            - using them just like numbers (which they are).

            - it turns out that we only need to add 1 to the address of numbers, 
            - instead of 4 (even though ints are 4 bytes in size), 

            - since the compiler already knows 
            - that the type of each value in numbers is 4 bytes. 
            - With + 1, we’re telling the compiler to move the next value in the array, 
            - not the next byte.

            - and notice that numbers is an array, 
            - but we can use it as a pointer with *numbers.
























String Comparison (methods):

    Comparing string will not work as expected 
    because the character == compares string via location
    that is, for it to be "true", they have to be in the same location in memory

        char *s = "Hi";
        char *t = "Hi";

        to the compiler, s != t


    One way around this, 
        - is to use the strcmp(s, t) function 
        - this lies in the string.h header file .
        - this function, will go to each string 
        - and compare the characted one by one


    Another way around this,
        - is to make "t"
        - such that it is also pointing to what "s" is pointing to
        - remember that when a pointer is declared, 
        - we will pass it an address that it will store

        - in this case, when "t" is declared, 
        - we will pass it the address "s" stores
        - note in this case, changes in "t" will affect "s" 

            char *s = "Hi";
            char *t = s;
























Pointer pointer:
    In C, 
        - we can also get the address of s or t, 
        - meaning the location of the pointer itself
        - and store them in a variable of the type char **, 
        - a pointer to a pointer.

        - INTERESTING RIGHT!!
























Memory allocation - string copy:

        + To actually make a copy of a string, we have to do a little more work, 
          and copy each character in "s" to somewhere else in memory.
            

        + Basically
            - we’ll need to use a new function, "malloc", 
            - to allocate some number of bytes in memory. 

            - and we’ll use "free" to mark memory as usable when we’re done with it, 
            - so the operating system can do something else with it.

            - our computers might slow down if a program we’re running has a bug 
            - where it allocates more and more memory but never frees it. 
            - The operating system will take longer and longer 
            - to find enough available memory for our program.


                #include <ctype.h>          (toupper)
                #include <stdlib.h>         (malloc, free)
                #include <string.h>

                int main(void)
                {   

                    // create a string
                    char *s = "hello";
                    int s_length = strlen(s);

                    // copy string into your allocated memory
                    char *t = malloc(s_length + 1);             // length of "s" + null character
                    for (int i =0; i<s_length + 1; i++){
                        t[i] = s[i];
                    }


                    // modify the copied string 
                    t[0] = toupper(t[0]);


                    printf("%s\n", s);
                    printf("%s\n", t);
                    free(t);
                }   

        + Alternatively, to copy a string, we can use the library function "strcpy"
          simply by the line strcpy(t, s); 
























Memory allocation  (out of memory contingencies): 

        + If our computer is out of memory, malloc will return 
            - NULL, 
            - the null pointer, or 
            - a special value of all 0 bits 
              that indicates there isn’t an address to point to. 



        + So we should check for that case, and exit if t is NULL.



        + We should also check that t has a length, 
          before trying to capitalize the first character.
          that is befor trying to work with it 
























Memory allocation  (valgrind): 


            #include <stdlib.h>

            int main(void)
            {
                int *x = malloc(3 * sizeof(int));

                if ( x == NULL)
                {
                    return 1;
                }

                x[1] = 4;
                x[2] = 5;
                x[3] = 6; 

            } 



        + The thing is that we made two mistakes here
            - we are touching memory that was not given to us via x[3]
              because we omitted the use of x[0]

            - we did not free the memory we allocated when we were done  


        
        + When we compile and run our program, 
            - though, nothing seems to happen. 
            - it turns out that our mistake wasn’t bad enough 
            - to cause a segmentation fault this time, though it might next time



        + valgrind 
            - is a command-line tool that we can use to run our program 
            - and see if it has any memory-related issues.  
            - We’ll run valgrind ./memory after compiling, 
              and we’ll see a lot of output:

            - we would see INVALID WRITE & LEAK SUMMARY  
            - which tells us, that we've written to memory we should not
              and we did not free some memory when we were done 
























Garbage values :

            int main(void)  
            {
                int scores[3];

                for (int i=0; i<3; i++)
                {
                    printf("%i\n", scores[i]);
                }
            }     


            $ make garbage
            $ ./garbage

            68476128
            32765
            0


        + We declare an array, scores, 
          but we didn’t initialize it with any values.


        + The values in the array are garbage values, 
          or whatever unknown values that were in memory, 
          from whatever program was running in our computer before.


        + If we aren’t careful with how our programs access memory, 
          users might end up seeing data from previous programs, like passwords. 


        + And if we try to go to an address that’s a garbage value, 
          our program is likely to crash from a segmentation fault.


        + When we can use a memory, 
          it does not neccesarily mean the memory space is cleared, empty
          old values are still there, it just means, we are free to change those values
























Garbage values  (expensive mistake):

            #include <stdlib.h>

            int main(void)
            {
                int *x;
                int *y;

                x = malloc(sizeof(int));

                *x = 42;
                *y = 13;
            }


        + from the first line, we declared two pointers
          now the values at this pointers will initially be garbage value
          meaning it is available for use, but have not necessarily been cleared


        + we are to place our own values, thus clearing the garbage values


        + notice for pointer x, we placed our own values
          which is the address of the memory allocation


        + but notice, for pointer y, we did not place our own values
          meaning we are using the garbage value in y, which is an address

          this is problematic 

          since we haven’t allocated any memory for y, and the garbage value there 
          points to some area in memory we likely don’t have access to.
























Arguments in C:

    + When an argument is passed into a function,
      it is the copies of the arguments that are passed
      not references to the argument like in other languages

        void swap(int a, int b)
        {
            ...
        }

        int x = 23;
        int y = 45;

        swap(x, y)


    + in the case, we want to create our program such that it has function
      that deals with references and not copied variable.

      our parameter for the function will be pointer not mere integer
      and our argument to the function will be addresses. typical right!!

        void swap (int *a, int *b)
        {
            int temp = *a;
            *a = *b;
            *b = temp;

        }

        int x = 23;
        int y = 45;

        swap(&x, &y)
























Memory Sectioning in C:

    Within our computer’s memory, different types of data 
    that need to be stored for our program are organized into different sections:
        machine code section, 
        globals section, 
        heap section (with arrow pointing downward), 
        stack section (with arrow pointing upward)


    Machine Code Section
        - section for our compiled program’s binary code. 
        - when we run our program, that code is loaded into memory.


    Globals Section 
        - just below, or in the next part of memory, 
        - are global variables we declared in our program.


    Heap Section    
        - the heap section is an empty area 
        - from where malloc can get free memory for our program to use. 
        - as we call malloc, we start allocating memory from the top down.
        - if we call malloc for too much memory, we will have a heap overflow, 
          since we end up going past our heap. 


    Stack Section   
        - this section is used by functions and local variables 
        - in our program as they are called, and grows upwards.
        - if we call too many functions without returning from them, 
          we will have a stack overflow, where our stack has too much memory allocated as well
























Input from user (scanf - integers):
    
    + scanf is an interesting function, it obtains input from user
      and stores that input in a location on the system


    + we have to tell scanf which location it should use.
      we might have to declare and array OR malloc a memory
      and give the address to scanf


    + Lets show a basic example (simply collecting an integer)

      int main(void)
      {
            int x;

            printf("x: ");
            scanf("%i\n", &x);

            printf("x: %i\n", x);

      }


    + scanf takes a format, %i, so the input is “scanned” for that format. 
      we also pass in the address in memory where we want that input to go with &x. 
























Input from user (scanf - string):

    + unlike with integers which is a basic datatype
      we need to allocate a memory to store the string input,
      if not, there will be no place to store the value.


        int main(void)
        {

            char *s = malloc(4);
            printf("Enter Your Name: ");
            scanf("%s", s);
            printf("%s\n", s);


        }


    + Note only four bytes was allocated for the string.
       in the case, where the input is "helloooooooooooooooo"
       now we are placing values in memory that is not our own
       thus we will have an error segmentation fault (core dump)
       causing our program to crash


    + get_string from the CS50 library continuously allocates more memory 
      as scanf reads in more characters, so it doesn’t have this issue.
























Working with files:

    int main(void)
    {
        // open the files as a file object in write mode
        FILE *file = fopen("phonebook.csv", "a");


        // is file object succesful?
        if (!file)
        {
            return 1;
        }


        char *s = "John";
        char *t = "09067427319"; 


        // write to the file object
        fprintf( file, "%s,%s\n", name, number);



        // close the file
        fclose(file);
    }
























Exercise 1:
    
    + Check if an image file is a JPEG File


    + First, 
        - we define a BYTE as 8 bits, 
        - so we can refer to a byte as a type more easily in C.


    + Then, 
        - we’ll read from a file with a function called fread.
        - fread takes in four argument
        - ARG_1 specifies the address, where the data is going into
        - ARG_2 specifies how many bits you want to read into the structure at once
        - ARG_3 specifies how many times you will read data into the struture
        - ARG_4 specifies the address where the data is coming from


    + Then,
        - we can compare the first three bytes (in hexadecimal) 
        - to the three bytes required to begin a JPEG file. 

        - If they’re the same, 
        - then our file is likely to be a JPEG file 
        - (though, other types of files may still begin with those bytes).
        - But if they’re not the same, we know it’s definitely not a JPEG file.


    + It turns out that BMP files, another format for images, 
      have even more bytes in its header, or beginning of the file. 


        #include <stdint.h>


        // create a data type called BYTE
        typedef uint8_t BYTE


        int main(int argc, int argv[1])
        {
            // check usage
            if (argc > 1){
                return 1;
            } 



            // open file
            FILE *file = fopen(argv[0], "r");
            if (!file)
            {
                return 2;
            }


            // read 3 bytes
            BYTE img_bytes[3];
            fread(img_bytes, sizeof(BYTE), 3, file);



            // compare first three bytes
            if (img_bytes[0] == 0xff && img_bytes[1] == 0xd8 && img_bytes[2] == 0xff)
            {
                printf("Yes, Possibly\n");
            }

        }




















Excercise 2:

    Here, 
        - we have a loop that iterates over / 
        - all the pixels in a two-dimensional array, 
        - and sets the blue and green values to 0.


    void filter ( int height, int width, RGBTRIPLE image [height][width] ) {

        for (int i = 0;  i < height;  i++){
            for (int j = 0;  j < width;  j++){
                image[h][w].rgbtBlue = 0;
                image[h][w].rgbtGreen = 0;
            }
        }

    }   



