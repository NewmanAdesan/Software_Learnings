






Starter Files:

	Projects contains Three starter files
		- bmp.h, 
		- filter.c, 
		- helpers.h, 
		- helpers.c, and 
		- Makefile


	Lets see each and every one of them	
























bmp header file  ( structures ):

	the files defines datatypes found in the world of Windows programming 
	this datatypes are just aliases for primitives data type in the language(C/C++)
		- BYTE, 
		- DWORD, 
		- LONG, and 
		- WORD


	You’ll see definitions of the headers we’ve mentioned 
		- BITMAPINFOHEADER and 
		- BITMAPFILEHEADER. 
		- (they make use of datatypes we defined)


	Perhaps most importantly for you, this file also defines a struct called RGBTRIPLE 
		- this quite simply, “encapsulates” three bytes: 
		- one blue, one green, and one red 
		- (the order, recall, in which we expect to find RGB triples actually on disk).
























bmp header file  ( benefits of structs ):

	I will say this first,
	structs acts as a powerful "EASE of REFERENCE" technique.


	They perform the function of "ENCAPSULATION"


	Why are these structs useful? 
		- recall that a file is just a sequence of bytes (or, ultimately, bits) on disk. 
		- but those bytes are generally ordered in such a way 
		- that the first few represent something, 
		- the next few represent something else, and so on. 

		- “File formats” exist because the world has standardized what bytes mean what. 
		- Now, we could just read a file from disk 
		- into RAM as one big array of bytes. 
		- And we could just remember that the byte at array[i] represents one thing, 
		- while the byte at array[j] represents another. 

		- but why not give some of those bytes names 
		- so that we can retrieve them from memory more easily via the names? think about it
		- That’s precisely what the structs in bmp.h allow us to do. 


	Rather than think of some file as one long sequence of bytes, 
	we can instead think of it as a sequence of structs.


	Do you understand? Think about it	
























filter source file:

	Now, let’s open up filter.c. This file has been written already for you, 
	but there are a couple important points worth noting here.



	First, 
		- notice the definition of filters on line 11. 
		- That string tells the program what the allowable 
		- command-line arguments to the program are: b, g, r, and s. 
		- each of them specifies a different filter that we might apply to our images: 
		- blur, grayscale, reflection, and sepia.

		- notice the use of the getopt built-in function
		- which is used for filtering command line arguments



	Next,
		- the next several lines open up an image file, 
		- make sure it’s indeed a BMP file, 
		- and read all of the pixel information into a 2D array called image



	Next,
		- scroll down to the switch statement that begins on line 102. 
		- notice that, depending on what filter we’ve chosen, 
		- a different function is called for instance s for sepia

		- Notice, too, that each of these functions take as arguments 
		- the height of the image, 
		- the width of the image, and 
		- the 2D array of pixels.	

		- these are the functions you’ll (soon!) implement. As you might imagine, 
		- the goal is for each of these functions to edit the 2D array of pixels 
		- in such a way that the desired filter is applied to the image.



	Lastly,
		- the remaining lines of the program 
		- take the resulting image and write them out to a new image file.		
























helpers header file :

	Next, take a look at helpers.h. This file is quite short, 
	and just provides the function prototypes for the functions you saw earlier.


	Here, take note of the fact that 
		- each function takes a 2D array called image as an argument, 
		- where image is an array of height many rows, 
		- and each row is itself another array of "width" many RGBTRIPLEs. 

		- So if image represents the whole picture, 
		- then image[0] represents the first row, 
		- and image[0][0] represents the pixel in the upper-left corner of the image,
		- remember this image is encapsulated in a structure called RGBTRIPLE.

		- Once you've broken it down, it's easy to flow through it.
		- you will find out, what you have to do is quite easy. :)
























helpers source file:

	Now, open up helpers.c. 


	Here’s where the implementation of the functions declared in helpers.h belong. 


	But note that, right now, the implementations are missing! This part is up to you.
























Makefile text file:

	Finally, let’s look at "Makefile". 


	This file specifies what should happen 
	when we run a terminal command like "make filter". 


	The programs you may have written before were confined to just one file, 
	therefore using the make shortcut was sufficient, 
	since its just a command that compiles one file.


	But now, filter seems to use multiple files: filter.c, bmp.h, helpers.h, and helpers.c. 
	therefore the make shortcut is no longer sufficient.


	So we’ll need to tell make how to compile this file, 
























Specification:

	Implement the functions in helpers.c such that a user can apply
	grayscale, sepia, reflection, or blur filters to their images.


	The function grayscale should take an image 
	and turn it into a black-and-white version of the same image.


	The function sepia should take an image 
	and turn it into a sepia version of the same image.


	The reflect function should take an image and reflect it horizontally.


	The blur function should take an image 
	and turn it into a box-blurred version of the same image.


	You should not modify any of the function signatures, 
	nor should you modify any other files other than helpers.c.
























Usage:

	Your program should behave per the examples below. 


		$ ./filter -g INFILE.bmp OUTFILE.bmp
		$ ./filter -s INFILE.bmp OUTFILE.bmp
		$ ./filter -r INFILE.bmp OUTFILE.bmp
		$ ./filter -b INFILE.bmp OUTFILE.bmp


	INFILE.bmp is the name of the input image and 
	OUTFILE.bmp is the name of the resulting image after a filter has been applied.
























Hints (1-3):

	Hints 1
		- the values of a pixel’s rgbtRed, rgbtGreen,
		- and rgbtBlue components are all integers, 
		- so be sure to round any floating-point numbers to the nearest integer 
		- when assigning them to a pixel value!



	Hints 2
		- when implementing the grayscale function, 
		- you’ll need to average the values of 3 integers. 
		- Why might you want to divide the sum of these integers by 3.0 and not 3?
		


	Hints 3	
		- in the reflect function, 
		- you’ll need to swap the values of pixels on opposite sides of a row. 
		- recall from lecture how we implemented /
		- swapping two values with a temporary variable. 
		- in this case, no need to use a separate function /
		- for swapping unless you would like to! 
























Hints (4-5):


	Hints 4	
		- a function that returns the lesser of two integers 
		- would come in handy while implementing sepia, 
		- particularly when you need to make sure a color’s value is no higher than 255?



	Hints 5	
		- when implementing the blur function, 
		- you might find that blurring one pixel 
		- ends up affecting the blur of another pixel. 

		- Perhaps create a copy of image (the function’s third argument) 
		- by declaring a new (two-dimensional) array 
		- with code like RGBTRIPLE copy[height][width]; 

		- and copying image into copy, pixel by pixel, with nested for loops? 
		- And then read pixels’ colors from copy 
		- but write (i.e., change) pixels’ colors in image?	
	